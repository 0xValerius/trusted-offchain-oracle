/// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

/**
 * @title OracleVerifier
 * @author 0xValerius
 * @notice OracleVerifier ensures the integrity of the data received from off-chain oracles by validating their signatures on-chain. The contract also maintains a list of trusted oracles, and only these trusted oracles can provide data.
 * @dev An abstract contract that implements on-chain signature verification. The contract allows for trusted oracles to provide off-chain data to the contract. This is achieved by verifying signatures generated off-chain.
 */
abstract contract OracleVerifier {
    /**
     * @dev Event emitted when the ownership of the contract is transferred.
     * @param previousOwner The address of the previous owner of the contract.
     * @param newOwner The address of the new owner of the contract.
     */
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Event emitted when the trust status of an off-chain oracle is updated.
     * @param _address The address of the off-chain oracle.
     * @param _isTrusted The new trust status of the off-chain oracle.
     */
    event UpdatedOffChainOracle(address indexed _address, bool _isTrusted);

    /**
     * @dev Throws if the caller is not the owner.
     */
    error NotTheOwner();

    /**
     * @dev Throws if the timestamp is invalid (either it is in the future or it exceeds the time threshold).
     */
    error InvalidTimeStamp();

    /**
     * @dev Throws if the signature length is not 65 bytes.
     */
    error InvalidSignatureLength();

    /**
     * @dev Throws if the computed message hash does not match the provided message hash.
     */
    error InvalidHash();

    /**
     * @dev Throws if the recovered address from the signature is not a trusted oracle.
     */
    error InvalidSigner();

    address private _owner;
    mapping(address => bool) private _isTrusted;
    uint256 private _timeThreshold;

    /**
     * @notice At the time of deployment, the contract ownership is automatically assigned to the address deploying the contract. From there, the owner has the power to transfer ownership using the `transferOwnership` function.
     * @dev The constructor sets the initial owner of the contract to the address that deployed the contract. It is called once and only once when the contract is deployed.
     */
    constructor() {
        _owner = msg.sender;
    }

    /**
     * @notice This modifier ensures that only the owner can call the function it is used in.
     * @dev Modifier that allows functions to be called only by the owner of the contract.
     */
    modifier onlyOwner() {
        if (msg.sender != _owner) {
            revert NotTheOwner();
        }
        _;
    }

    /**
     * @notice This modifier ensures the integrity of the data received from the off-chain oracle and that it was indeed generated by a trusted oracle. It uses EIP-191 style signatures.
     * @dev Modifier that verifies the signature, timestamp, and message hash of the data received from an off-chain oracle.
     * @param data The raw data received from the oracle.
     * @param timestamp The timestamp at which the data was generated.
     * @param messageHash The hash of the data and the timestamp.
     * @param signature The signature generated by the off-chain oracle using its private key.
     */
    modifier verify(bytes memory data, uint256 timestamp, bytes32 messageHash, bytes memory signature) {
        if (timestamp > block.timestamp || block.timestamp - timestamp > _timeThreshold) {
            revert InvalidTimeStamp();
        }

        if (signature.length != 65) {
            revert InvalidSignatureLength();
        }

        bytes32 expectedMessageHash = keccak256(abi.encodePacked(data, timestamp));
        if (expectedMessageHash != messageHash) {
            revert InvalidHash();
        }

        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash));

        bytes32 s;
        bytes32 r;
        uint8 v;

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (!_isTrusted[ecrecover(ethSignedMessageHash, v, r, s)]) {
            revert InvalidSigner();
        }

        _;
    }

    /**
     * @notice Be careful when changing the owner of the contract, as it will allow the new owner to add or remove trusted oracles.
     * @dev This function transfers the ownership of the contract to a new address. It is public and can only be called by the current owner of the contract.
     * @param newOwner The address of the new owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }

    /**
     * @dev This function returns the current owner of the contract. It is external and view.
     */
    function owner() external view returns (address) {
        return _owner;
    }

    /**
     * @notice The time threshold defines the maximum allowed delay for off-chain data to be valid. If the data delay exceeds this threshold, it will be considered invalid.
     * @dev This function allows the owner to set the time threshold. It is external and can only be called by the owner.
     * @param newTimeThreshold The new time threshold in seconds.
     */
    function setTimeThreshold(uint256 newTimeThreshold) external onlyOwner {
        _timeThreshold = newTimeThreshold;
    }

    /**
     * @notice It is essential to maintain an updated list of trusted oracles to prevent unauthorized data inputs.
     * @dev This function allows the owner to update the trust status of an off-chain oracle. It is external and can only be called by the owner.
     * @param oracleAddress The address of the off-chain oracle.
     * @param oracleStatus The new trust status of the off-chain oracle.
     */
    function manageTrusted(address oracleAddress, bool oracleStatus) external onlyOwner {
        _isTrusted[oracleAddress] = oracleStatus;
        emit UpdatedOffChainOracle(oracleAddress, oracleStatus);
    }

    /**
     * @dev This function returns the current time threshold. It is external and view.
     */
    function timeThreshold() external view returns (uint256) {
        return _timeThreshold;
    }

    /**
     * @dev This function checks if an address is a trusted oracle. It is external and view.
     * @param _address The address to check.
     * @return True if the address is a trusted oracle, otherwise false.
     */
    function isTrusted(address _address) external view returns (bool) {
        return _isTrusted[_address];
    }
}
